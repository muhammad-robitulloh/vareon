from pydantic import BaseModel, Field
from typing import Optional, Dict, Any, List, Literal
from datetime import datetime
import uuid

# --- Arcana Agent Schemas ---

class ArcanaAgentBase(BaseModel):
    name: str = Field(..., description="The name of the Arcana agent.")
    persona: str = Field("default", description="The persona or personality of the agent (e.g., 'developer', 'analyst').")
    mode: str = Field("chat", description="The operational mode of the agent (e.g., 'chat', 'autonomous', 'tool_user').")
    objective: Optional[str] = Field(None, description="The primary objective or goal for the agent, especially in autonomous mode.")
    status: str = Field("idle", description="The current status of the agent (e.g., 'idle', 'running', 'stopped').")
    configuration: Optional[Dict[str, Any]] = Field(None, description="JSON field for agent-specific configuration.")
    target_repo_path: Optional[str] = Field(None, description="The local path of the Git repository the agent should operate on.")
    target_branch: Optional[str] = Field(None, description="The Git branch the agent should operate on.")

class ArcanaAgentCreate(ArcanaAgentBase):
    pass

class ArcanaAgentUpdate(BaseModel):
    name: Optional[str] = None
    persona: Optional[str] = None
    mode: Optional[str] = None
    objective: Optional[str] = None
    status: Optional[str] = None
    configuration: Optional[Dict[str, Any]] = None
    target_repo_path: Optional[str] = None
    target_branch: Optional[str] = None

class ArcanaAgentResponse(ArcanaAgentBase):
    id: str
    owner_id: str
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- Arcana API Key Schemas ---
class ArcanaApiKeyBase(BaseModel):
    api_key: str = Field(..., description="The API key string.")
    owner_id: str = Field(..., description="The ID of the user who owns this API key.")
    expires_at: Optional[datetime] = Field(None, description="The expiration date and time of the API key.")
    is_active: bool = Field(True, description="Whether the API key is currently active.")

class ArcanaApiKeyCreate(ArcanaApiKeyBase):
    # When creating, the API key itself might be generated by the system,
    # but we include it here for consistency if it's provided externally.
    pass

class ArcanaApiKeyUpdate(BaseModel):
    expires_at: Optional[datetime] = None
    is_active: Optional[bool] = None

class ArcanaApiKeyResponse(ArcanaApiKeyBase):
    id: str
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- User CLI Config Schemas ---
class UserCliConfigBase(BaseModel):
    user_id: str = Field(..., description="The ID of the user this CLI config belongs to.")
    config_key: str = Field(..., description="The key of the CLI configuration setting.")
    config_value: Dict[str, Any] = Field(..., description="The JSON value of the CLI configuration setting.")

class UserCliConfigCreate(UserCliConfigBase):
    pass

class UserCliConfigUpdate(BaseModel):
    config_value: Dict[str, Any]

class UserCliConfigResponse(UserCliConfigBase):
    id: str
    created_at: datetime
    updated_at: datetime

    class Config:
        orm_mode = True

# --- Code Generation Schemas ---
class CodeGenerationRequest(BaseModel):
    prompt: str = Field(..., description="The natural language prompt for code generation.")
    language: str = Field("python", description="The programming language for the generated code (e.g., 'python', 'javascript', 'java').")
    context: Optional[str] = Field(None, description="Additional context or existing code to inform the generation.")
    model_name: Optional[str] = Field(None, description="Specific LLM model to use for code generation. If None, a default will be selected.")

class CodeGenerationResponse(BaseModel):
    generated_code: str = Field(..., description="The generated code.")
    language: str = Field(..., description="The programming language of the generated code.")
    model_used: str = Field(..., description="The LLM model used for generation.")
    reasoning: Optional[str] = Field(None, description="Optional explanation or reasoning behind the generated code.")
    success: bool = Field(True, description="Indicates if the code generation was successful.")
    error_message: Optional[str] = Field(None, description="Error message if generation failed.")

# --- Shell Command Translation Schemas ---
class ShellCommandTranslationRequest(BaseModel):
    prompt: str = Field(..., description="The natural language instruction to translate into a shell command.")
    current_directory: Optional[str] = Field(None, description="The current working directory for context.")
    shell_type: str = Field("bash", description="The type of shell (e.g., 'bash', 'zsh', 'powershell').")
    model_name: Optional[str] = Field(None, description="Specific LLM model to use for translation. If None, a default will be selected.")

class ShellCommandTranslationResponse(BaseModel):
    translated_command: str = Field(..., description="The translated shell command.")
    reasoning: Optional[str] = Field(None, description="Optional explanation or reasoning behind the translated command.")
    model_used: str = Field(..., description="The LLM model used for translation.")
    is_safe: bool = Field(False, description="Indicates if the translated command is considered safe for execution.")
    safety_warning: Optional[str] = Field(None, description="Warning message if the command is potentially unsafe.")
    success: bool = Field(True, description="Indicates if the translation was successful.")
    error_message: Optional[str] = Field(None, description="Error message if translation failed.")

# --- Reasoning System Schemas ---
class ReasoningRequest(BaseModel):
    prompt: str = Field(..., description="The user's prompt or task for which reasoning is required.")
    context: Optional[str] = Field(None, description="Additional context (e.g., chat history, code snippets, file contents) for reasoning.")
    task_type: str = Field("general", description="The type of task for which reasoning is being generated (e.g., 'general', 'code_generation', 'shell_command').")
    model_name: Optional[str] = Field(None, description="Specific LLM model to use for reasoning. If None, a default will be selected.")

class ReasoningStep(BaseModel):
    step_number: int = Field(..., description="The order of the reasoning step.")
    description: str = Field(..., description="Description of the reasoning step.")
    action: Optional[str] = Field(None, description="The action planned or taken for this step.")
    outcome: Optional[str] = Field(None, description="The expected or actual outcome of the action.")

class ReasoningResponse(BaseModel):
    reasoning_trace: List[ReasoningStep] = Field(..., description="A detailed trace of the AI's thought process.")
    summary: Optional[str] = Field(None, description="A high-level summary of the reasoning.")
    model_used: str = Field(..., description="The LLM model used for generating reasoning.")
    success: bool = Field(True, description="Indicates if reasoning generation was successful.")
    error_message: Optional[str] = Field(None, description="Error message if reasoning generation failed.")

from server_python.git_service.schemas import GitDiffRequest, GitDiffResponse # Import Git schemas

# --- File Operations Schemas ---
class FileOperationRequest(BaseModel):
    action: Literal["read", "write", "delete", "list", "create_directory", "rename"] = Field(..., description="The file operation to perform.")
    path: str = Field(..., description="The path to the file or directory.")
    new_path: Optional[str] = Field(None, description="The new path for 'rename' operation.")
    content: Optional[str] = Field(None, description="Content to write for 'write' operation.")
    recursive: bool = Field(False, description="For 'list' or 'delete' operations, whether to operate recursively.")

class FileInfo(BaseModel):
    name: str
    path: str
    is_directory: bool
    size: Optional[int] = None
    last_modified: Optional[datetime] = None

class FileOperationResponse(BaseModel):
    success: bool = Field(..., description="Indicates if the file operation was successful.")
    message: str = Field(..., description="A message describing the outcome of the operation.")
    content: Optional[str] = Field(None, description="Content of the file for 'read' operation.")
    file_list: Optional[List[FileInfo]] = Field(None, description="List of files/directories for 'list' operation.")
    error_message: Optional[str] = Field(None, description="Error message if the operation failed.")

# --- Git Operations Tool Schema ---
# This schema is for the agent to call the git_get_diff tool
GIT_GET_DIFF_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "git_get_diff",
        "description": "Generates a diff of changes in the Git repository. Can be used to see unstaged changes or changes to a specific file.",
        "parameters": {
            "type": "object",
            "properties": {
                "local_path": {"type": "string", "description": "The local path of the Git repository."},
                "path": {"type": "string", "description": "Optional: The path to a specific file to get the diff for. If not provided, gets diff for all unstaged changes."}
            },
            "required": ["local_path"]
        }
    }
}

# --- Test Running Tool Schema ---
RUN_TESTS_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "run_tests",
        "description": "Executes test commands within a specified repository path and returns the output.",
        "parameters": {
            "type": "object",
            "properties": {
                "local_path": {"type": "string", "description": "The local path of the repository where tests should be run."},
                "command": {"type": "string", "description": "The shell command to execute for running tests (e.g., 'pytest', 'npm test')."}
            },
            "required": ["local_path", "command"]
        }
    }
}

# --- Context Memory Tool Schemas ---
STORE_CONTEXT_ITEM_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "store_context_item",
        "description": "Stores a piece of information in the agent's long-term context memory, categorized by type.",
        "parameters": {
            "type": "object",
            "properties": {
                "item_type": {"type": "string", "enum": ["preference", "project", "conversation"], "description": "The category of the context item (e.g., 'preference', 'project', 'conversation')."},
                "key": {"type": "string", "description": "A unique key or name for the context item within its type (e.g., 'Preferred Language', 'Project X Overview')."},
                "value": {"type": "object", "description": "The actual content of the context item as a JSON object."}
            },
            "required": ["item_type", "key", "value"]
        }
    }
}

RETRIEVE_CONTEXT_ITEMS_TOOL_SCHEMA = {
    "type": "function",
    "function": {
        "name": "retrieve_context_items",
        "description": "Retrieves context items from the agent's long-term memory, optionally filtered by type and key.",
        "parameters": {
            "type": "object",
            "properties": {
                "item_type": {"type": "string", "enum": ["preference", "project", "conversation"], "description": "Optional: The category of context items to retrieve."},
                "key": {"type": "string", "description": "Optional: A specific key of the context item to retrieve."}
            }
        }
    }
}

# --- Agent Orchestration Schemas ---
class AgentExecuteRequest(BaseModel):
    task_prompt: str = Field(..., description="The natural language prompt describing the task for the agent.")
    agent_id: str = Field(..., description="The ID of the Arcana Agent to execute the task.")
    context: Optional[str] = Field(None, description="Additional context for the agent's task.")
    target_repo_path: Optional[str] = Field(None, description="The local path of the Git repository the agent should operate on.")
    target_branch: Optional[str] = Field(None, description="The Git branch the agent should operate on.")

class AgentExecuteResponse(BaseModel):
    agent_id: str = Field(..., description="The ID of the Arcana Agent that executed the task.")
    status: str = Field(..., description="The status of the agent's execution (e.g., 'success', 'failed', 'in_progress').")
    output: Optional[str] = Field(None, description="The output or result of the agent's task.")
    actions_taken: Optional[List[str]] = Field(None, description="A list of actions the agent performed.")
    error_message: Optional[str] = Field(None, description="Error message if the execution failed.")

# --- Agent Job & Log Schemas ---

class ArcanaAgentJobLogResponse(BaseModel):
    id: str
    timestamp: datetime
    log_type: str
    content: str

    class Config:
        orm_mode = True

class ArcanaAgentJobBase(BaseModel):
    agent_id: str
    status: str
    goal: str

class ArcanaAgentJobCreate(ArcanaAgentJobBase):
    pass

class ArcanaAgentJobResponse(ArcanaAgentJobBase):
    id: str
    owner_id: str
    created_at: datetime
    updated_at: datetime
    ended_at: Optional[datetime] = None
    final_output: Optional[str] = None
    message_history: Optional[List[Dict[str, Any]]] = Field(None, nullable=True) # New: Stores JSON of LLM messages
    original_request: Optional[AgentExecuteRequest] = Field(None, nullable=True) # New: Stores JSON of original AgentExecuteRequest
    logs: List[ArcanaAgentJobLogResponse] = []

    class Config:
        orm_mode = True

class HumanInputRequest(BaseModel):
    human_input: str = Field(..., description="The message or clarification from the human user.")
    context: Optional[str] = Field(None, description="Additional context provided by the human user.")